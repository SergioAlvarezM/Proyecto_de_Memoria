# BEGIN GPL LICENSE BLOCK
#
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# END GPL LICENSE BLOCK

"""
File that contains the functions to read files in NetCDF4 format.
"""
from typing import Union
from src.utils import get_logger
from src.error.netcdf_import_error import NetCDFImportError
from src.utils import LATITUDE_KEYS, LONGITUDE_KEYS, HEIGHT_KEYS

import numpy as np
from netCDF4 import Dataset

log = get_logger(module='NETCDF')


def get_variables_from_grp(grp, key_values: list) -> Union[list, None]:
    """
    Get the list of values from a grp object.

    Args:
        key_values: Possible key values to search for
        grp: Grp object generated by the netcdf4 library

    Returns: List with values
    """
    grp_keys = grp.variables.keys()

    # Check for the key to be in the object
    for key in key_values:
        if key in grp_keys:
            return grp.variables[key]

    return None


def read_info(file_name: str) -> (np.ndarray, np.ndarray, np.ndarray):
    """
    Extract the information of X, Y and Z from a NetCDF4 file.

    The keys to use for extracting the information of the longitude, latitude and height are stored in the files
    longitude_keys.json, latitude_keys.json and height_keys.json respectively.

    In case that the file  does not have a key to extract either the longitude, latitude or height, then an
    NetCDFImportError is raised proportioning as data a dictionary with the keys accepted as the parameter and the
    keys stored in the read file.

    Important:
        Due to how some files are generated, if the longitude or latitude keys are missing, then the method ask
        for the parameters x_range, y_range and spacing in the file. if they are defined in the file, then the program
        generates the X and Y values from the values defined in the parameters. If they are not defined, then the
        NetCDFImportError exception is raised with the information of the keys accepted and the keys that are inside the
        file.

    Return a tuple with 3 elements in the format (X, Y, Z):
        X: 1-dimensional array.
        Y: 1-dimensional array.
        Z: 2-dimensional array.

    Args:
        file_name (str): Filename to analyze.

    Returns: 
        Tuple with the values of the variables X, Y and Z in the file.
    """
    root_grp = Dataset(file_name, "r", format="NETCDF4")

    x = get_variables_from_grp(root_grp, LONGITUDE_KEYS)
    y = get_variables_from_grp(root_grp, LATITUDE_KEYS)
    z = get_variables_from_grp(root_grp, HEIGHT_KEYS)

    # ask if the file have the values defined as ranges and spacing/dimensions
    if x is None:
        x_range_values = get_variables_from_grp(root_grp, ['x_range'])
        x_range_array = np.array(x_range_values)
        if x_range_values is None or len(x_range_array) < 2:
            raise NetCDFImportError(3, {'accepted_keys': LONGITUDE_KEYS,
                                        'file_keys': root_grp.variables.keys()})

        spacing_values = get_variables_from_grp(root_grp, ['spacing'])
        spacing_array = np.array(spacing_values)
        if spacing_values is None or len(spacing_array) < 2:
            raise NetCDFImportError(3, {'accepted_keys': LONGITUDE_KEYS,
                                        'file_keys': root_grp.variables.keys()})

        x = np.arange(x_range_array[0], x_range_array[1], spacing_array[0]).tolist() + [x_range_array[1]]

    # ask if the file have the values defined as ranges and spacing/dimensions
    if y is None:
        y_range_values = get_variables_from_grp(root_grp, ['y_range'])
        y_range_array = np.array(y_range_values)
        if y_range_array is None or len(y_range_array) < 2:
            raise NetCDFImportError(2, {'accepted_keys': LATITUDE_KEYS,
                                        'file_keys': root_grp.variables.keys()})

        spacing_values = get_variables_from_grp(root_grp, ['spacing'])
        spacing_array = np.array(spacing_values)
        if spacing_values is None or len(spacing_array) < 2:
            raise NetCDFImportError(2, {'accepted_keys': LATITUDE_KEYS,
                                        'file_keys': root_grp.variables.keys()})

        y = np.arange(y_range_array[0], y_range_array[1], spacing_array[1]).tolist() + [y_range_array[1]]

    if z is None:
        raise NetCDFImportError(4, {'accepted_keys': HEIGHT_KEYS,
                                    'file_keys': root_grp.variables.keys()})

    # shape the arrays to work
    x = np.array(x)
    y = np.array(y)
    z = np.array(z)

    # check the case the z_array is unidimensional
    if z.ndim == 1:
        z = z.reshape((len(y), len(x)))
        z = np.flipud(z)

    root_grp.close()

    return x, y, z


if __name__ == "__main__":
    # filename = "../../test/input/files/test_file_2.nc"
    filename = "../../resources/sample_netcdf/38Ma_HotSpot.nc"
    rootgrp = Dataset(filename, "r", format="NETCDF4")

    print("Dimensiones del archivo:")
    print(rootgrp.dimensions)

    print("Grupos del archivo:")
    print(rootgrp.groups)

    print("Variables del archivo:")
    print(rootgrp.variables)

    X, Y, Z = read_info(filename)

    print("X values")
    print(X)

    print("Y values")
    print(Y)

    print("Z values.")
    print(Z)

    rootgrp.close()
